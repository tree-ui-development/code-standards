<!-- #### DOM SECTION #### -->

<!--  TODO: create dom4.js -->

<section id="dom">

	<div class="intro has-icon">
		<img class="icon" src="img/layout/icon-curly.png" alt="{}" />
		
		<h1>DOM</h1>
		
		<p>The <strong>Document Object Model (DOM)</strong> is a language-independant API that represents the structure of a web page programmatically. Much of what we define as front end engineering centers on manipulating this structure, so a solid understating of the DOM is crucial to being a well rounded Front End Engineer.</p>
	</div>

	<h2>Access and Modification</h2>
	
	<p>Directly, manipulating the DOM is slow. Each time you access or modify a piece of it, you pay in performance. It's better to do manipulations in what PPK called "DOM Hyperspace" and then push changes into the document when the manipulations are completed. This is especially important when doing loops on collections of elements.</p>
    <p>While assigning variables to a local scope is always a good practice, caching DOM fragments and properties to local variables is especially important.</p>
		
	<textarea class="brush:javascript">
	function htmlLoop() {
		var fragment;
		for(var i = 0; i < 1000; i++ ) {
			fragment += '<p>a</p>';
		}
		document.getElementById('fragment').innerHTML += stuff;
	}
	</textarea>

	<h3>Element Nodes</h3>
	
	<p>A problem with several common DOM accessor methods is that they return <strong>all</strong> nodes- including text nodes. The *element* node methods return <strong>only</strong> element nodes. Most of the time, element nodes are the preferred return value.</p>
	
	<table>
		<tr>
			<th>Use these:</th>
			<th>Instead of:</th>
		</tr>
		<tr>
			<td>children</td>
			<td>childNodes</td>
		</tr>
		<tr>
			<td>childElementCount</td>
			<td>childNodes.length</td>
		</tr>
		<tr>
			<td>firstElementChild</td>
			<td>firstChild</td>
		</tr>
		<tr>
			<td>lastElementChild</td>
			<td>lastChild</td>
		</tr>
		<tr>
			<td>nextElementSibling</td>
			<td>nextSibling</td>
		</tr>
		<tr>
			<td>previousElementSibling</td>
			<td>previousSibling</td>
		</tr>
	</table>
	
		
	<h3>Selectors API</h3>
	
	<dl>
		<dt>querySelector()</dt>
		<dd>Select specific elements in a page.</dd>
		<dt>querySelectorAll()</dt>
		<dd>Returns a collection of nodes that match the selector.</dd>
	</dl>


	<h2>Reflow &amp; Repaint</h2>
	
	<p>So the browser has:</p>
	
	<dl>
		<dt>A <em>DOM</em> tree</dt>
		<dd>A representation of the page structure.</dd>
		<dt>A <em>Render</em> tree</dt>
		<dd>A representation of how the DOM nodes will be displayed.</dd>
	</dl>
	
	<p>The render tree has at least one node for every node in the DOM tree that needs to be displayed (not including hidden elements). Nodes in the render tree are treated like CSS <em>frames or boxes</em>. Boxes can have properties like borders, padding, margins, etc.</p>
	
	<p>When a change in the DOM effects the geometry of an element, the browser needs to recalculate the geometry of that element and the elements around it that may be effected as well. The browser invalidates the effected part of the render tree, and reconstructs it. This process is known as a <em>reflow</em>. Once the reflow is completed the browser can then redraw the effected part of the screen. A process known as <em>repaint</em>.</p>
	

	<h3>Avoid things that cause reflows</h3>
	
	<!-- Add things here. -->
	
	
	<h3>Queing and Flusing Render Tree Changes</h3>
	
	<ul>
		<li>offsetTop/Left/Width/Height</li>
		<li>scrollTop/Left/Width/Height</li>
		<li>clientTop/Left/Width/Height</li>
		<li>getComputedStyle() (cuurentStyle in IE)</li>
	</ul>

	<p>This video shows how Firefox constructs a page.</p>
	
	<iframe width="480" height="390" src="http://www.youtube.com/embed/ZTnIxIA5KGw" frameborder="0" allowfullscreen></iframe>

</section>